---
title: 【Linux】Linux总结（待完善）
comments: true
abbrlink: 2c8b313c
categories:
  - 基础知识
  - Linux
  - Linux基础
tags:
  - Linux
date: 2025-07-11 11:53:32
description:
top:
---

## 文件系统介绍

### 根目录结构及其功能

**系统目录结构：**

| 目录     | 内容                                                         |
| -------- | ------------------------------------------------------------ |
| **bin**  | **目录全称(binary) 存放二进制命令文件(普通用户可以使用)**    |
| sbin     | 目录存放二进制命令文件(root用户可以使用)                     |
| **etc**  | **目录存放软件程序或系统程序配置文件**                       |
| lib      | 目录会存放需要调取库文件信息 旧软件程序调取库文件            |
| lib64    | 目录会存放需要调取库文件信息 新软件程序调取库文件            |
| media    | 可以存放实例视频或图片 可以用于作为默认挂载点                |
| mnt      | 可以用于作为默认挂载点                                       |
| opt      | 目录存放第三方软件程序数据 等价于Windows program files       |
| usr      | 目录存放第三方软件程序数据 等价于Windows program files       |
| **root** | **用户信息存放家目录 root用户的家 ~**                        |
| home     | 用户信息存放家目录 普通用户的家~                             |
| boot     | 目录存放系统启动相关的数据                                   |
| **dev**  | **目录会存放一些设备文件信息**                               |
| **var**  | **目录全称(variable),用于存放日志文件的**                    |
| tmp      | 目录用于临时存放文件信息 类似于Windows 回收站                |
| **proc** | **由内核组成，目录中会存放系统内核配置信息或服务进程信息，不会占用磁盘空间，只会占用内存空间** |

### 系统配置信息

| 文件                                    | 路径                                                         |
| --------------------------------------- | ------------------------------------------------------------ |
| 网卡配置（centos）                      | /etc/sysconfig/network-scripts/ifcfg-ens33<br>/etc/sysconfig/network-scripts/ifcfg-eth0 |
| 网卡配置（kali）                        | /etc/systemd/networkd.conf                                   |
| 主机名                                  | /etc/hostname                                                |
| 域名配置文件                            | /etc/resolv.conf                                             |
| 环境变量                                | /etc/profile<br />/etc/bashrc<br />~/.bash_profile <br />~/.bashrc |
| 开机自动加载命令文件                    | /etc/rc.d/rc.local                                           |
| 用户登录信息提示文件                    | /etc/motd                                                    |
| 系统版本信息                            | /etc/[redhat/centos/os(kali是os)]-release                    |
| 用户相关文件信息                        | /etc/passwd                                                  |
| cpu相关信息，包括型号、主频、内核信息等 | /proc/cpuinfo                                                |
| 操作系统版本信息                        | /proc/version                                                |
| 系统全局 cron 配置文件                  | /etc/crontab                                                 |
| docker配置文件                          |                                                              |
| nginx配置文件                           |                                                              |
| nginx启动文件                           |                                                              |
| 配置函数信息的文件                      | /etc/init.d/functions                                        |
|                                         | /etc/docker/daemon.json                                      |
| docker代理配置文件                      | /etc/systemd/system/docker.service.d/http-proxy.conf         |

| 目录                                        | 路径             |
| ------------------------------------------- | ---------------- |
| 自动加载运行脚本目录                        | /etc/profile.d/  |
| 系统安装软件目录(rpm 手动方式 yum 自动方式) |                  |
| 存放独立 cron 配置文件的目录                | /etc/cron.d/     |
| 每个用户的 cron 表存储目录                  | /var/spool/cron/ |



### 日志信息

Linux系统拥有非常灵活和强大的日志功能，可以保存几乎所有的操作记录，并可以从中检索出我们 需要的信息。

1. 内核及系统日志
由系统服务rsyslog统一进行管理，日志格式基本相似
2. 用户日志
记录系统用户登录及退出系统的相关信息
3. 程序日志
由相应的应用程序进行独立管理。如：web服务，ftp服务 常见日志文件

| **日志文件**                           | **作用**                                                     |
| -------------------------------------- | ------------------------------------------------------------ |
| **/var/log/secure**                    | **登录日志。记录验证和授权方面的信息，只要涉及账号和密码的程序都会记录， 比如 SSH登录， su登录，切换用户， sudo授权，甚至添加用户和修 改用户密码都会记录在这 个日志文件中。新版的ubuntu、debian、kali已经没有这个文件了 ， 换成了 /var/log/auth.log** |
| /var/log/message                       | 通用的系统活动日志。记录内核消息、系统服务（邮件、cron等）的常规信息、非关键网络错误等。 |
| /var/log/cron                          | 每当cron进程开始一个工作时，就 会将相关信息记录在这个 文件中。 |
| /var/log/syslog                        | 所有系统活动信息（比 `messages` 更全面）。包含内核、服务、应用等除认证外的所有信息。 |
| **/var/log/wtmp**                      | **永久记录所有用户的登录、注销信息，同时记录系统的启动、重启、 关机事件。同样这个文件也是一个二进制文件，不能直接编辑查看， 而需要使用 last命令来查看** |
| **/var/run/utmp**                      | **记录当前已经登录的用户信息，这个文件会随着用户的登录和注销不 断变化，只记录当前登录用户的信息。同样这个文件不能直接编辑查 看，而要使用 w,who,users等命令来查询** |
| **/var/log/btmp**                      | **记录所有失败登录日志信息。这个文件是二进制文件，不能直接编辑 查看，使用 lastb命令或 last -f /var/log/btmp 命令可以查看btmp文件。** |
| /var/log/cups                          | 涉及所有打印信息的日志。                                     |
| /var/log/faillog                       | 包含用户登录失败信息。此外，错误登录命令也会记录在本文件中   |
| /var/log/messages                      | 记录系统重要信息的日志。这个日志文件中会记录Linux系统的绝大 多数重要信息，如果系统出现问题时，首先要检查的就应该是这个日 志文件。此外， mail，cron，daemon，kern和auth等内容也记录在var/log/messages |
| /var/log/dmesg                         | 包含内核缓冲信息（ kernel ring buffer）。在系统启动时，会在屏幕上显示许多与硬件有关的信息。可以用 dmesg命令直接查看内核自检信息 |
| **/var/log/auth.log**                  | **包含系统授权信息，包括用户登录和使用的权限机制等。**       |
| /var/log/boot.log                      | 包含系统启动时的日志。                                       |
| /var/log/daemon.log                    | 包含各种系统后台守护进程日志信息。                           |
| /var/log/dpkg.log                      | 包括安装或 dpkg命令清除软件包的日志。                        |
| /var/log/kern.log                      | 包含内核产生的日志，有助于在定制内核时解决问题。             |
| **/var/log/lastlog**                   | **记录系统中所有用户最后一次登录时间的日志，这个文件是二进制文 件，不能直接编辑查看，而要使用 lastlog命令查看** |
| /var/log/user.log                      | 记录所有等级用户信息的日志。                                 |
| /var/log/alternatives.log              | 更新替代信息都记录在这个文件中。                             |
| /var/log/anaconda.log                  | 在安装Linux时，所有安装信息都储存在这个文件中。              |
| /var/log/yum.log                       | 包含使用 yum安装的软件包信息。                               |
| /var/log/maillog<br/>/var/log/mail.log | 包含系统运行电子邮件服务器的日志信息。例如， sendmail日志信息就全部送到这个 文件中 |

比较重要的几个日志：

> 登录失败记录：/var/log/btmp    #lastb
> 最后一次登录：/var/log/lastlog #lastlog
> 登录成功记录: /var/log/wtmp    #last
> 登录日志记录：/var/log/secure
> 目前登录用户信息：/var/run/utmp #w、who、users
> 历史命令记录：history
> 仅清理当前用户：history -c

### 网卡配置

```bash
vim  /etc/sysconfig/network-scripts/ifcfg-ens33
# 网络接口类型（通常为 Ethernet 或 Bridge）
TYPE=Ethernet
# 代理配置方式（none 表示不使用代理）
PROXY_METHOD=none
# 是否仅用于浏览器代理（no 表示不限制）
BROWSER_ONLY=no
# 获取IP地址的方式（static 表示静态IP，dhcp 表示动态获取）
BOOTPROTO=static
# 静态IP地址（需根据实际网络规划设置）
IPADDR=10.0.0.5
# 子网掩码（定义IP地址的网络部分）
NETMASK=255.255.255.0
# 默认网关（路由器的IP地址）
GATEWAY=10.0.0.254
# 主DNS服务器地址（注意：此处错误添加了域名，应仅保留IP）
DNS1=10.0.0.254
# 是否启用默认路由（yes 启用）
DEFROUTE=yes
# IPv4配置失败时是否视为严重错误（no 表示不终止网络服务）
IPV4_FAILURE_FATAL=no
# 是否初始化IPv6（yes 启用）
IPV6INIT=yes
# 是否自动配置IPv6地址（yes 启用）
IPV6_AUTOCONF=yes
# 是否启用IPv6默认路由（yes 启用）
IPV6_DEFROUTE=yes
# IPv6配置失败时是否视为严重错误（no 表示不终止网络服务）
IPV6_FAILURE_FATAL=no
# IPv6地址生成模式（增强隐私保护）
IPV6_ADDR_GEN_MODE=stable-privacy
# 网络连接名称（自定义标识）
NAME=ens33
# 设备唯一标识符（系统自动生成，通常无需修改）
UUID=27a73818-89f3-4991-9890-2da7924a73c4
# 物理设备名称（需与网卡实际名称一致）
DEVICE=ens33
# 是否在系统启动时激活此连接（yes 启用）
ONBOOT=yes
```

更改配置需要重启网卡`systemctl restart network`  或 `service network restart`

### 域名解析配置

```bash
vim /etc/resolv.conf    #域名解析配置文件
nameserver 10.0.0.254   #DNS服务器，不能写错 写错就访问不了了
cat /cat /etc/hosts     #访问内网的域名配置文件
```

## 系统管理

### 环境变量

和变量 环境变量 别名相关的配置文件信息：`/etc/profile`、`/etc/bashrc`、`~/.bash_profile` 、`~/.bashrc`、`/etc/profile.d/`

网安关注应急效应，异常占用资源、进程关闭后再次运行，有可能是 profile 被植入脚本运行命令。`/etc/profile` 、`/etc/bashrc`、两个文件写到任意一个都会受到影响（把某个恶意跑进程的脚本放进去）。局部变量优于全局变量

如果想让变量重启后仍然有效就修改这些文件。

### **其他**

**文件时间信息分类**

| 文件时间信息分类 | 英文全称      | 缩写  | 触发条件                                       |
| ---------------- | ------------- | ----- | ---------------------------------------------- |
| 文件修改时间     | modified time | mtime | 文件信息内容发生变动时，会修改调整此时间信息   |
| 文件访问时间     | access time   | atime | 文件信息内容被访问读取时，会修改调整此时间信息 |
| 文件改变时间     | change time   | ctime | 文件属性信息发生变动时，会修改调整此时间信息   |

**inode与block**

文件索引-inode 数据信息索引 每创建一个文件可用的索引次数就会减少

文件大小-block 数据信息容量 文件中的信息内容不断添加，数据块就会不断减少

查看相关信息：

df -i --inode 可用数为0 表示磁盘空间不足

df  block 可用数 为0 表示磁盘空间不足

inode：默认大小为128或者256字节

block：默认大小1-4kb

由于磁盘分区都比较大，所以一个磁盘中会创建出大量的inode和block

本质上有数字编号和实际存储空间对应 便于检索数据信息 ---指针 库管 会议 仓库提货过程

存储的数据文件中包含数据文件属性 

描述数据的数据 – 元数据

### 系统进程

程序（Program）是经开发编译后形成的静态可执行代码集合，是数据与指令的有序封装（如磁盘中存储的`wechat.exe`或`nginx`二进制文件），其生命周期独立于运行状态，可长期保存在存储介质中。

当程序被加载到内存并开始执行时，便转化为**进程（Process）**—— 它是程序的动态运行实例。此时，操作系统会为其分配专属的系统资源（如内存空间、CPU 时间片、文件描述符等），并记录其运行状态（如就绪、运行、阻塞等）。同时，进程会关联明确的所属用户，受系统权限管控。

简言之，程序是 “静态的代码文件”，而进程是 “动态的执行过程”。例如，双击`wechat.exe`后，操作系统将其加载到内存并启动执行，此时任务管理器中显示的 “微信” 进程，便是该程序的运行实例。

#### 进程与程序的本质区别

| 维度     | 程序（Program）                          | 进程（Process）                                              |
| -------- | ---------------------------------------- | ------------------------------------------------------------ |
| 存在形态 | 静态：以二进制文件、脚本等形式存储于磁盘 | 动态：加载到内存中执行的指令流与数据集合                     |
| 资源关联 | 不占用系统运行时资源（仅占用存储资源）   | 占用 CPU、内存、I/O 等实时系统资源                           |
| 生命周期 | 长期存在（除非主动删除文件）             | 随执行开始而创建，随任务完成或异常终止而消亡（有明确生命周期） |
| 核心属性 | 仅包含代码逻辑与静态数据                 | 包含运行状态、资源句柄、进程 ID（PID）、所属用户等动态元信息 |

理解进程与程序的区别，是系统运维的基础：程序是 “待执行的蓝图”，而进程是 “正在施工的现场”—— 运维的核心工作，正是通过监控、管理这些 “现场”，确保系统按预期稳定运行。

根据进程生命周期，存在两种特殊进程情况：

- 僵尸进程：

异常进程 任务没处理完子进程崩溃了，就会出现僵尸进程（Z） 儿子死了父亲还在 关注 木马病毒 产生大量Z 会占用大量内存资源

- 孤儿进程：

异常进程 任务处理完毕告知父进程时，父进程异常了，产生孤儿进程，系统会自动回收孤儿进程 了解

#### **查看当前静态进程情况**

**`ps -ef`|`ps aux`**

```bash
ps aux   #USER, PID, %CPU, %MEM, VSZ, RSS, TTY, STAT, START, TIME, COMMAND
ps -ef   #UID, PID, PPID, C, STIME, TTY, TIME, CMD
```

以下是 `ps aux` 和 `ps -ef` 命令中所有列的英文缩写及含义对照表：


| 英文缩写 | 含义说明                                                     | 出现命令       |
| -------- | ------------------------------------------------------------ | -------------- |
| USER     | 进程所属的用户名（用户标识，字符串形式）                     | ps aux         |
| PID      | Process ID，进程唯一标识符（进程 ID）                        | ps aux、ps -ef |
| %CPU     | 进程占用的 CPU 资源百分比（单位：%）                         | ps aux         |
| %MEM     | 进程占用的物理内存百分比（单位：%）                          | ps aux         |
| VSZ      | Virtual Set Size，虚拟内存大小（单位：KB，包含物理内存和交换空间等） | ps aux         |
| RSS      | Resident Set Size，实际占用的物理内存大小（单位：KB，不包含交换空间） | ps aux         |
| TTY      | 进程关联的终端设备（`?` 表示无终端关联，通常为后台进程）     | ps aux、ps -ef |
| STAT     | Process State，进程状态（如 R 运行、S 睡眠、Z 僵尸、T 停止等） | ps aux         |
| START    | 进程启动的时间（格式随系统时间范围变化，如时分、月日等）     | ps aux         |
| TIME     | 进程累计占用的 CPU 时间（格式：时：分: 秒）                  | ps aux、ps -ef |
| COMMAND  | 启动进程的完整命令及参数                                     | ps aux         |
| UID      | User ID，进程所属用户的 ID（用户标识，数字形式）             | ps -ef         |
| PPID     | Parent Process ID，父进程的 ID（标识当前进程的父进程）       | ps -ef         |
| C        | CPU 使用率（整数形式，反映进程近期的 CPU 占用情况，精度低于 % CPU） | ps -ef         |
| STIME    | 进程启动的时间（格式更紧凑，通常为时分或月日，随系统时间范围变化） | ps -ef         |
| CMD      | 启动进程的命令及参数（可能因长度限制被截断）                 | ps -ef         |

#### 查看当前动态进程情况

`top` 输出分为 **系统全局状态区** 与 **进程详情区**，两者共同构成系统实时运行快照。

在 Linux 系统运维中，`top` 命令是实时监控进程资源与系统性能的核心工具。它通过动态刷新的界面，提供 CPU、内存、进程状态等关键指标，帮助管理员快速定位资源瓶颈与异常进程。

top与 ps 命令的核心差异：

| 工具  | 特性                                                     | 适用场景                         |
| ----- | -------------------------------------------------------- | -------------------------------- |
| `ps`  | 静态快照，捕获某一时刻的进程状态（如 `ps -aux`）。       | 记录历史状态、排查进程启动参数。 |
| `top` | 动态监控，实时刷新资源占用与进程行为（默认 3 秒 / 次）。 | 实时性能分析、异常进程定位。     |

##### 系统全局状态区

系统全局状态区为输出的上半部分，以典型输出为例：

```bash
top - 09:27:45 up 5 days,  7:45,  4 users,  load average: 0.00, 0.01, 0.05  
Tasks: 123 total,   1 running, 121 sleeping,   1 stopped,   0 zombie  
%Cpu(s):  0.1 us,  0.0 sy,  0.0 ni, 99.9 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st  
KiB Mem :  1863032 total,  1121288 free,   256980 used,   484764 buff/cache  
KiB Swap:  1535996 total,  1535996 free,        0 used.  1408888 avail Mem  
```

1. **第一行（系统基础信息）**

   - `09:27:45`：当前系统时间。

   - `up 5 days, 7:45`：系统已连续运行 5 天 7 小时 45 分钟（未重启）。

   - `4 users`：当前登录用户数（含本地终端与远程连接）。

   - ```bash
     load average: 0.00, 0.01, 0.05
     ```

     ：系统平均负载，分别对应过去 1 分钟、5 分钟、15 分钟的活跃进程数。

     - **关键逻辑**：负载值代表处于 **可运行状态（`R`）** 或 **不可中断休眠状态（`D`）** 的进程数平均值。
     - **健康指标**：若 1 分钟负载值超过 CPU 核心数（如 4 核 CPU 负载 >4），表明系统短期过载；若 15 分钟负载持续偏高，需排查长期资源瓶颈。

2. **第二行（进程总数统计）**

   - `123 total`：系统总进程数。
   - `1 running`：处于 `R` 状态的进程数（正在占用或等待 CPU）。
   - `121 sleeping`：处于 `S`（可中断休眠）或 `D`（不可中断休眠）状态的进程数。
   - `1 stopped`：处于 `T`（停止）状态的进程数（如被 `Ctrl+z` 暂停的 `ping` 进程）。
   - `0 zombie`：僵尸进程（`Z` 状态）数量，若大于 0 需检查父进程是否未回收资源。

3. **第三行（CPU 资源占用）**

   - **`us`：用户态进程占用 CPU 的百分比（如应用程序）**。
   - `sy`：内核态进程占用 CPU 的百分比（如系统调用、进程调度）。
   - `ni`：调整过优先级（`nice` 值非 0）的用户态进程占用 CPU 的百分比。
   - `id`：CPU 空闲百分比（数值越高，系统越空闲）。
   - **`wa`：CPU 等待 I/O 操作（如磁盘读写）的百分比，若长期高于 5% 需排查存储性能。**
   - `hi`：硬中断（如硬件设备触发的中断）占用 CPU 的百分比。
   - `si`：软中断（如内核定时器、网络数据包处理）占用 CPU 的百分比。
   - `st`：虚拟化环境中，物理 CPU 被其他虚拟机占用的百分比（`st` 过高可能意味着宿主机资源竞争）。

4. **第四、五行（内存与交换分区）**

   - `KiB Mem`（物理内存）：
     - `total`：总容量；`free`：完全空闲内存；`used`：进程直接占用内存；`buff/cache`：磁盘缓存（可释放供其他进程使用）。
   - `KiB Swap`（虚拟内存）：
     - `avail Mem`：新进程可使用的总内存（含 `free` 及可释放的 `buff/cache`）。


##### 进程详情区（下半部分）

以典型输出为例：

```bash
PID USER      PR  NI    VIRT    RES    SHR S  %CPU %MEM     TIME+ COMMAND  
53720 root      20   0       0      0      0 S   0.3  0.0   0:18.08 kworker/1:1  
    1 root      20   0  202396   7300   4184 S   0.0  0.4   5:01.00 systemd  
    2 root      20   0       0      0      0 S   0.0  0.0   0:00.93 kthreadd  
```

**字段说明：**

| 字段      | 含义说明                                                     |
| --------- | ------------------------------------------------------------ |
| `PID`     | 进程唯一标识，操作进程的核心索引（如 `kill 53720`）。        |
| `USER`    | 进程所属用户，用于权限追溯（如 `root` 进程通常拥有更高权限）。 |
| `PR`      | 进程调度优先级（范围 0-39，值越低优先级越高，内核动态调整）。 |
| `NI`      | `nice` 值（优先级偏移量，范围 -20~19，值越低优先级越高，用户可通过 `nice` 命令调整）14。 |
| `VIRT`    | 进程占用的虚拟内存总量（包括物理内存、交换分区、未使用的分配内存），类似 “建筑面积”。 |
| `RES`     | 进程实际使用的物理内存（不包括交换分区），类似 “实际使用面积”。 |
| `SHR`     | 进程共享的内存量（如动态链接库），类似 “公摊面积”。          |
| `S`       | 进程状态（`R` 运行、`S` 休眠、`T` 停止、`Z` 僵尸等）。       |
| `%CPU`    | 进程占用 CPU 的百分比（过去 3 秒内的平均值）。               |
| `%MEM`    | 进程占用物理内存的百分比（相对于总物理内存）。               |
| `TIME+`   | 进程累计占用的 CPU 时间（精确到 0.01 秒）。                  |
| `COMMAND` | 启动进程的命令（含参数时会截断显示，按 `c` 可显示完整路径）。 |

##### 核心功能与快捷键

`top` 命令以交互式界面实时展示系统状态，支持以下核心操作：

1. **基础交互**
   - `h` 或 `?`：调出帮助文档，查看所有快捷键与功能说明。
   - `q`：退出监控界面。
   - `s` 或 `d`：调整刷新间隔（单位：秒），默认 3 秒刷新一次。
2. **资源排序**
   - `P`：按 CPU 使用率（`%CPU`）降序排序，快速定位高负载进程。
   - `M`：按内存使用率（`%MEM`）降序排序，排查内存占用异常。
   - `T`：按累计 CPU 时间（`TIME+`）排序，识别长期占用资源的进程。
3. **视图优化**
   - `1`：展开多核 CPU 视图，显示每个物理核心的负载详情（如 `%Cpu0`、`%Cpu1`）。
   - `z`：启用颜色高亮，区分不同数据区域（如红色标记高负载进程）。
   - `b`：高亮显示处于 `R`（运行）状态的进程，直观识别活跃任务。
4. **高级控制**
   - `k`：终止进程（输入 PID 后可指定信号，如 `9` 强制终止）。
   - `r`：调整进程优先级（通过 `nice` 值，范围 -20~19，值越小优先级越高）。
   - `c`：切换显示进程完整命令行（含参数），避免因名称截断导致的误判。

##### 关键指标与异常排查

1. **性能瓶颈定位**
   - **CPU 过载**：若 `%CPU` 长期高于 80%，按 `P` 排序找出高负载进程，结合 `ps -fp <PID>` 分析代码逻辑或考虑扩容。
   - **内存泄漏**：若 `%MEM` 持续增长且 `avail Mem` 下降，按 `M` 排序排查异常进程，使用 `pmap` 或 `valgrind` 分析内存分配。
   - **磁盘 I/O 瓶颈**：若 `wa` 长期高于 10%，使用 `iotop` 定位高 I/O 进程，优化存储或升级硬件。
2. **进程状态异常**
   - **僵尸进程（`Z` 状态）**：终止父进程（`kill <PPID>`）或修复程序逻辑（确保调用 `wait()` 回收子进程资源）。
   - **不可中断进程（`D` 状态）**：可能因磁盘 I/O 阻塞，使用 `strace` 跟踪系统调用或检查存储设备健康状态。
3. **虚拟化环境监控**
   - 若 `st` 持续高于 10%，表明宿主机资源不足，需迁移虚拟机或增加物理 CPU 核心。

##### 数据保存与高级用法

1. **批处理模式记录日志**

   ```bash
   top -b -n 5 > /tmp/top_monitor.log  # 记录 5 次刷新结果到文件  
   ```

   - `-b`：以批处理模式运行，适合脚本调用或离线分析。
   - `-n 5`：指定刷新次数，避免无限输出。

2. **自定义显示字段**

   - 按 `f` 进入字段选择界面，通过方向键添加 / 删除字段（如 `CODE` 代码内存、`DATA` 数据段内存）。
   - 按 `o` 调整字段顺序（如将 `%CPU` 列移至首位）。

3. **多进程监控**

   ```bash
   top -p 1234,5678  # 同时监控多个进程（PID 1234 和 5678）  
   ```

#### 进程状态（STAT）信息

在 Linux 系统中，通过`ps`、`top`等命令查看进程时，状态标识（如`R`、`S`、`Z`等）直观反映了进程的当前行为。以下是各状态及相关符号的说明：

##### **核心状态标识**

进程状态由内核根据其资源占用、调度情况动态标记，核心状态标识（Process State Codes）如下：

1. **`R`（Running / Runnable，运行状态）**
   进程处于 “可被 CPU 调度” 的状态：要么正在占用 CPU 执行指令，要么已就绪（等待 CPU 分配时间片）。此时进程位于内核的 “就绪队列” 中，是系统中 “活跃” 的典型代表。

2. **`S`（Interruptible Sleep，可中断休眠状态）**
   进程因等待某事件（如 I/O 操作完成、信号触发、定时器超时等）而暂停执行，此时不占用 CPU 资源。该状态可被外部信号（如`SIGINT`）中断并唤醒（例如通过`kill`命令发送信号）。

   状态衍生符号（优先级相关）：

   - `S<`：表示进程处于高优先级可中断休眠状态（优先级高于默认值），内核会优先调度其唤醒。
   - `SN`：表示进程处于低优先级可中断休眠状态（优先级低于默认值），调度优先级较低。

3. **`T`（Stopped / Traced，停止 / 跟踪状态）**
   进程被主动暂停执行，通常由以下场景触发：

   - 收到暂停信号（如`SIGSTOP`），例如通过`Ctrl+z`暂停前台进程（如`ping 223.5.5.5`执行时，`Ctrl+z`会将其暂停为`T`状态）；
   - 被调试器（如`gdb`）跟踪，处于断点调试状态。

   该状态的进程可通过`SIGCONT`信号恢复运行（如`fg`命令将后台暂停进程调至前台），适用于暂不明确进程作用时 —— 先暂停而非直接`kill`，降低误操作风险。

   操作示例：

   - 暂停进程：`ping 223.5.5.5`执行中按`Ctrl+z`，进程进入`T`状态；
   - 查看暂停任务：`jobs`命令（仅显示当前终端会话创建的任务）；
   - 恢复进程：`fg %1`（将编号为 1 的暂停任务调至前台继续运行）；
   - 彻底终止：`Ctrl+c`直接终止前台进程，或`kill`命令发送终止信号。

4. **`D`（Uninterruptible Sleep，不可中断休眠状态）**
   进程因等待 “不可中断的系统资源”（如磁盘 I/O、硬件设备响应）而进入深度休眠，**不响应任何外部信号**（包括`kill -9`）。其设计目的是确保关键资源操作的原子性（如 MySQL 执行大量数据写入时，需等待磁盘同步完成，避免数据一致性问题）。

   注意：`D`状态进程虽不直接占用 CPU，但会锁定相关资源，若长期存在可能暗示硬件故障（如磁盘读写超时）。

5. **`Z`（Zombie，僵尸状态）**
   子进程已终止（退出），但父进程未调用`wait()`系列系统调用回收其资源（如进程 ID、退出状态等），导致其残留于进程表中。僵尸进程不占用 CPU、内存等实际资源，但会消耗进程表项（系统进程 ID 数量有限），积累过多可能导致新进程无法创建。

##### 状态辅助符号

除核心状态外，`ps`命令还会显示以下符号，用于描述进程的附加属性：

- `s`：进程为**会话首进程**（Session Leader），通常是进程组的父进程，负责管理整个进程组的生命周期（如终端启动的命令进程多为会话首进程）。
- `<`：进程运行在**高优先级**（对应`S<`状态，优先级值低于默认，Linux 优先级范围为 - 20~19，值越小优先级越高）。
- `N`：进程运行在**低优先级**（对应`SN`状态，优先级值高于默认）。
- `+`：进程属于**前台进程组**，直接接收终端输入（如当前终端执行的`ls`命令进程）。
- `l`：进程包含**多个线程**（Lightweight Process），多线程进程可并行处理多个任务（如微信同时运行文字聊天、视频通话等功能，分别由不同线程执行），提升 CPU 利用率与响应速度。

结合`ps`、`top`等工具查看进程状态变化，通过状态标识可快速判断进程是否正常运行、是否存在资源竞争、是否需要干预（如终止僵尸进程、排查 D 状态进程的资源瓶颈）。

#### 进程控制：kill 命令

`kill` 命令通过向进程发送 **信号（signal）** 实现进程控制（终止、暂停、重启等），核心语法为：

```bash
kill [参数] <进程标识符（PID）>
```

##### 核心参数说明

- `-l`：列出所有可用信号（共 64 种，格式如 `1) SIGHUP 9) SIGKILL`）。
- `-s <信号>`：指定发送的信号（可用名称或编号，如 `-s SIGKILL` 或 `-9`）。
- `-p`：仅输出目标进程的 PID，不发送任何信号（用于验证进程存在性）。

##### 常用信号及场景

| 信号名称  | 编号 | 功能说明                                                     |
| --------- | ---- | ------------------------------------------------------------ |
| `SIGHUP`  | 1    | 通知进程重新加载配置文件（如 `nginx` 服务重载）。            |
| `SIGINT`  | 2    | 中断进程（通常由 `Ctrl+C` 触发，可被进程捕获处理）。         |
| `SIGKILL` | 9    | 强制终止进程（不可被捕获或忽略，适用于无法正常终止的进程）。 |
| `SIGTERM` | 15   | 优雅终止进程（默认信号，允许进程释放资源后退出，优先推荐使用）。 |
| `SIGSTOP` | 19   | 暂停进程（不可被忽略，需配合 `SIGCONT` 恢复）。              |
| `SIGCONT` | 18   | 恢复被 `SIGSTOP` 暂停的进程。                                |

##### 注意事项

1. **权限要求**：仅进程所有者或 `root` 可发送信号（普通用户无法终止其他用户的进程）。
2. **强制终止风险**：`SIGKILL`（信号 9）可能导致数据丢失（如未保存的文件），尤其对存储服务（如数据库）需谨慎使用。
3. **信号重试**：部分守护进程可能忽略 `SIGTERM`，可先尝试 `SIGTERM`，无效再用 `SIGKILL`。

#### 系统平均负载

平均负载定义为 **单位时间内，系统中处于「可运行状态（R）」和「不可中断状态（D）」的平均进程数**（即**活跃进程数**），与 CPU 使用率无直接关联：

- **可运行状态（R）**：正在占用 CPU，或等待 CPU 调度的进程（`ps`命令可见）。
- **不可中断状态（D）**：等待硬件 I/O 响应的进程（如磁盘写入时的保护机制，中断会导致数据一致性问题，`ps`命令可见为`D`状态）。

##### 系统平均负载的合理范围

系统平均负载的合理范围与 CPU 核心数强绑定。理想状态：**平均负载 ≈ CPU 核心数**（每个核心恰好运行 1 个进程）。不同核心数下，相同负载的意义截然不同：

| CPU 核心数 | 平均负载 = 2 的含义                   |
| ---------- | ------------------------------------- |
| 4 核       | CPU 使用率 50%（50% 资源空闲）        |
| 2 核       | CPU 使用率 100%（资源刚好用满）       |
| 1 核       | CPU 使用率 200%（50% 进程需等待 CPU） |

##### 时间维度的解读

平均负载包含 **1 分钟、5 分钟、15 分钟** 三个值，需结合判断趋势：

- **三者接近** → 负载平稳；
- **1 分钟值 ≫ 15 分钟** → 近期负载突增（需紧急排查）；
- **1 分钟值 ≪ 15 分钟** → 近期负载下降（关注历史瓶颈）。

**告警建议**：当平均负载超过 CPU 核心数的 70% 时，建议介入分析（需结合历史数据动态调整阈值）。

##### 与 CPU 使用率的区别

平均负载涵盖 **等待 CPU、等待 I/O、进程调度** 的进程，而 CPU 使用率仅统计 CPU 繁忙程度，二者在不同场景下表现不同：

| 序号 | 负载升高场景   | 平均负载变化 | use%   | sys%   | wait%  | CPU 整体使用率       | 磁盘 IO 消耗 |
| ---- | -------------- | ------------ | ------ | ------ | ------ | -------------------- | ------------ |
| 01   | CPU 密集型进程 | 升高         | 消耗多 | 消耗少 | 消耗少 | 使用率高（某个核心） | 磁盘消耗小   |
| 02   | IO 密集型进程  | 升高         | 消耗少 | 消耗多 | 消耗多 | 使用率低             | 磁盘消耗大   |
| 03   | 大量进程产生   | 升高         | 消耗多 | 消耗少 | 消耗多 | 使用率高（所有核心） | 磁盘消耗小   |

##### 问题排查核心思路

1. **查看负载**：通过 `uptime`/`top` 获取 1/5/15 分钟负载值，判断趋势。
2. **分析 CPU**：用 `mpstat` 查看多核负载、iowait 等指标，定位瓶颈类型（CPU 计算 / IO 等待）。
3. **定位进程**：通过 `pidstat`/`top` 追踪高负载进程（CPU/IO 占用异常的进程）。
4. **日志溯源**：结合进程所属服务的日志，分析代码逻辑或资源配置问题。

**压力测试与监控工具**：

stress是Linux系统压力测试工具，可以用作异常进程模拟平均负载升高的场景。

mpstat:是多核CPU性能分析工具，用来实时查看每个CPU的性能指标，以及所有CPU的平均指标;

pidstat:是常用的进程性能分析工具，用来实时查看进程的CPU、内存、1/0以及上下文切换等性能指标;

```bash
yum install -y sysstat stress  # sysstat含mpstat/pidstat，stress用于压力测试
```

### 系统管理命令

```bash
# history 查看历史命令
history -c   #清除历史记录（慎用）

#关机命令 --关闭虚拟系统
shutdown -h now    #立即关机
shutdown -h 0      #立即关机
shutdown -h now    #立即关机
shutdown -h 5      #五分钟之后关机
init 0             #立即关机
half               #立即关机

#重启命令
shutdown -r 0/now  #立即重启
init 6             #立即重启
reboot             #立即重启

#修改主机名（修改之后要bash命令刷新）
hostname name   #临时修改
hostnamectl set-hostname name  #永久修改

#2> 错误重定向
command 2>/dev/null

#which 查找$PATH中设置命令及安装文件目录所在位置
which cat

#export 设置环境变量，使其在当前 shell 及子进程中生效
#临时设置
export NAME                # 导出已存在的变量为环境变量
export NAME=value          # 定义并导出变量 “=”两侧不能有空格
NAME=value; export NAME    # 等价写法
unset NAME                 # 删除变量
#永久设置
echo 'export JAVA_HOME="/opt/java"' >> /etc/profile   # 对所有用户生效
echo 'export PATH="$PATH:~/.local/bin"' >> ~/.bashrc  # 仅对当前用户生效

#env
env | grep NAME      # 检查环境变量

#alternatives 管理系统命令的多版本实现，避免文件冲突
alternatives --config <命令名>        # 手动选择版本
alternatives --remove <名称> <路径>   # 移除版本
alternatives --display <名称>        # 查看所有可用版本
alternatives --install <链接> <名称> <路径> <优先级>  # 添加新版本

#crontab 设置周期性执行的任务
crontab -e	        #编辑当前用户的 cron 表（首次使用会选择编辑器）。
crontab -l	        #列出当前用户的所有定时任务。
crontab -r	        #删除当前用户的所有定时任务（谨慎使用）。
crontab -u user -e	#以 root 身份编辑指定用户的 cron 表（需 root 权限）。
#时间格式：[分钟] [小时] [日期] [月份] [星期] command
#通配符与特殊符号："*"：匹配所有值 | ","：分隔多个值 | "-"：指定范围 | "/"：指定间隔
#相对时间：@daily | @weekly | @monthly | @reboot

# free  查看空间使用情况
free -h

# df 查看磁盘使用情况
df -h

#ps
a     # 显示现行终端机下的所有程序，包括其他用户的程序。
-A    # 显示所有程序。
c     # 列出程序时，显示每个程序真正的指令名称，而不包含路 径，参数或常驻服务的标示。
-e    # 此参数的效果和指定"A"参数相同。
e     # 列出程序时，显示每个程序所使用的环境变量。
f     # 用ASCII字符显示树状结构，表达程序间的相互关系。
-H    # 显示树状结构，表示程序间的相互关系。
-N    # 显示所有的程序，除了执行ps指令终端机下的程序之外。
s     # 采用程序信号的格式显示程序状况。
u     # 以用户为主的格式来显示程序状况。
x     # 显示所有程序，不以终端机来区分
ps aux   #USER, PID, %CPU, %MEM, VSZ, RSS, TTY, STAT, START, TIME, COMMAND
ps -ef   #UID, PID, PPID, C, STIME, TTY, TIME, CMD
# 若关注资源占用和用户名，用 ps aux；若需分析进程关系或用户 ID，用 ps -ef

#设置别名
alias eth0='cat /etc/sysconfig/network-scripts/ifcfg-ens33'
#取消别名
unalias eth0
#永久设置
alias eth0='cat /etc/sysconfig/network-scripts/ifcfg-eth0' >> /etc/profile

#timedatectl  --修改时区信息，以及显示系统时间   内容比较详细
#date    --快速简介显示时间信息
#"%Y" 年year| "%m" 月mouth | "%d" 日day | "%H" 时hour | "%M" 分min | "%S" 秒sec | "%F" 年-月-日 
touch `date +%F`.txt

#jobs bg fg
jobs   #用于查看后台运行启动
bg     #将进程信息放入后台运行
fg     #将进程信息放入前台运行

#uname [选项]
-a 或 --all	             #显示全部系统信息，涵盖系统名称、主机名、内核版本、处理器类型等内容。
-s 或 --kernel-name	     #显示内核名称，像 Linux、Darwin（macOS）等。
-n 或 --nodename	         #显示主机名，也就是计算机在网络中的标识名称。
-r 或 --kernel-release	 #显示内核版本号，例如 5.15.0-76-generic。

tail /var/log/messages    #查看系统报错日志
```



## 文件管理

### 文件类型

![image-20250714181833893](【Linux】总结/image-20250714181833893.png)

①文件属性索引节点 --inode(唯一的)--身份证号
②文件属性信息和文件权限信息
③文件硬链接数:查看文件数据信息的多个门(类似于挂载)
④文件属主信息:文件管理者/文件创建者
⑤文件属组信息/所属用户组信息: 便于进行权限整体分配
⑥文件数据信息大小尺寸
⑦文件数据最后修改时间信息（Mtime）

文件类型:告诉系统管理者这个文件是什么类型 f(-) d c b s p l 

| 文件类型     | 字符 | 含义                                                         |
| ------------ | :--: | ------------------------------------------------------------ |
| 普通文件     |  -   | 文本 图片等                                                  |
| 目录文件     |  d   | 目录                                                         |
| 链接字文件   |  \|  | ==Windows 桌面快捷方式                                       |
| 块设备文件   |  b   | 存储数据以供系统存取的接口设备，简单而言就是硬盘。           |
| 字符设备文件 |  c   | 即串行端口的接口设备，例如键盘、鼠标等等。                   |
| 套接字文件   |  s   | 这类文件通常用在网络数据连接。可以启动一个程序来监听客户端的要求，客户端就可以通过套接字来进行数据通信。第一个属性为 [s]，最常在 /var/run目录中看到这种文件类型 |
| 管道文件     |  p   | FIFO也是一种特殊的文件类型，它主要的目的是，解决多个程序同时存取一个文件所造成的错误。FIFO是first-in-first-out(先进先出)的缩写。 |

![image-20250719173617460](【Linux】总结/image-20250719173617460.png)

软连接与硬链接：

软连接 l

硬链接 f

软连接：可以方便调取数据信息

复制连接的时候注意 复制的原文件的inode 是真实的文件

注意： 软链接的inode 和原文件的inode 是不一样的

​    硬链接的inode和原文件的inode是完全一样的

软链接是一个新的文件  删除不会有影响 

删除硬链接会删除原文件（如果有多个硬链接，删除到最后一个硬链接会删除原文件）

修改硬链接 即修改原文件



### 文件管理命令

```bash
#1 mkdir
mkdir directionName     #创建目录
mkdir {src,tools}       #同时创建两个文件夹
mkdir -p a/b/c/         #创建多级目录

#2 ls ll
ls -l    #查看目录下的文件属性信息  等于ll
ls -lh   #以人类可读方式显示文件大小信息  等于ll -h
ls -a    #查看目录下所有的数据信息 包含隐藏文件
ls -li   #查看文件属性索引节点indode  等于ll -i

#3 cd    #带'/'绝对路径，不带'/'相对路径
cd ~     #返回家目录 或直接 cd
cd /     #返回根目录
cd ..    #切换至上级目录
cd -     #切换至上次所在目录
cd ~user #进入到用户根目录

# pwd    #查看当前所在目录

#4 rm
rm -r filename filename   #递归删除
rm -f     #强制删除（无需确认）

#5 cp
cp  /路径/旧文件  /路径/新文件
cp  -r  /路径/目录   /路径/目录 #拷贝目录下的所有文件到另一目录
-a      #保持文件原有属性，该选项通常在复制目录时使用，它保留链接、文件属性，并递归地复制目录
cp a.txt b.txt #拷贝并改名


#6 mv
mv  文件/目录  新目录/
mv a b   #修改文件名

#7 touch
touch filename   #创建新文件
touch {filename1,filename2}  #同时创建
touch {1..5}.txt #创建1.txt 2.txt 3.txt 4.txt 5.txt 

#8 cat
cat -n filename  #[带行号]查看文件内容
cat test.txt >> README  #将test.txt的内容追加到README文件中
cat>>a<<EOF      #追加新内容
> hello
> EOF
cat>a<<EOF     #覆盖原始内容
> world
> EOF
head [-n]      #查看n行（默认10行）
tail [-n]      #查看末尾n行（默认10行）
tail -f        #动态查看文件，可用于追踪日志文件信息变化

#9 重定向
echo "123456">hxjl.txt   #覆盖重定向
echo "123456">>hxjl.txt  #追加重定向

#10 echo
echo -e         #激活转义字符
echo -E         #不激活转义字符
echo $envname   #打印环境变量
echo "this is test" > test.txt #写入文件

#11 grep
grep [-参数] string filename   #文件中筛选字符串；
-i             #不区分大小写
-n             #显示行号
-c             #统计匹配的行数
-v             #排除指定信息

#wc [选项] [文件...]
-l	    #只显示行数（lines）
-w	    #只显示单词数（words）
-c	    #只显示字节数（characters）
-m	    #只显示字符数（包括多字节字符，如中文）
-L	    #显示最长行的长度

#12 tree 展示目录下的结构

#13 lrzsz
rz -y           #从Windows上传文件到Linux

#14 wget
wget url        #下载Web内容到本机

#15 file 
file fileName   #查看文件类型/属性

#16 rpm RPM是Red Hat公司随Redhat Linux推出了一个软件包管理器，通过它能够更加轻松容易地实现软件的安装。
#常见用法：
rpm -ivh <rpm包名>        #安装软件
rpm -e <rpm包名>          #卸载安装
rpm -Uvh <rpm包名>        #升级一个rpm
rpm -qi <rpm包名>         #显示软件安装信息
rpm -qa | grep xxx       #查询软件是否安装（包括相关依赖）
rpm -qc <包名>	        #仅列出包的配置文件
rpm -qd <包名>	        #仅列出包的文档文件（手册、README等）
rpm -qlp <RPM文件路径>	   #查询未安装的RPM包内包含哪些文件
rpm -q --scripts <包名>	#查看包的安装/卸载脚本
-i, --install	     #安装软件包	rpm -ivh package.rpm
-v	--verbose        #列出更多详细信息，安装进度	rpm -v install package.rpm
-h, --hash           #安装时列出hash标记 (与 -v连用)  rpm -ihv package.rpm
-U, --update	     #升级软件包	rpm -Uvh new-package.rpm
-e, --erase	         #卸载软件包	rpm -e package-name
-V, --verify         #校验软件包文件完整性	rpm -V httpd
-l	                 #列出文件 (list files)
–test                #安装测试，并不实际安装
-q, --query 	     #查询软件包信息	rpm -q httpd
 -a, --all           #查询/校验所有的安装包
 -p, --package       #查询/校验一个安装文件
 -l, --list          #列出安装文件
 -d, --docfiles      #列出所有文档文件
 -f, --file          # 查询/校验安装包中所包含的文件

#17 stat
stat filename    #查看文件属性（Size、Blocks、Inode、Atime、Mtime、Ctime等）

#18 cut
-c n1-n2         #截取n1到n2的字符

#19 find 
find  查找路径 选项参数(查找数据条件)  操作语句
-mtime +10  #10天前
-mtime -10   #10天内
-name "c.sh"#文件名
-name "hxjl*.txt"#支持正则
-type d     #文件类型
! -type d   #取反
-size ±1M #文件大小
-perm 644 #文件权限
-exec  ls  -l  {}  \;  #执行命令

#locate 基于数据库快速查找文件，比 find 更高效
-i	     #忽略大小写（如 locate -i readme 匹配 README 和 readme）。
-w	     #按整词匹配（如 locate -w /etc 仅匹配 /etc 目录而非 /etc/passwd）。
-c	     #只返回匹配的文件数量，不显示文件名（如 locate -c bashrc）。
-e	     #只显示存在的文件（过滤已删除但仍在数据库中的记录）。
--regex	 #使用正则表达式匹配（如 locate --regex '.*\.(jpg|png)'）。
locate *.pdf  # 匹配所有 PDF 文件
locate -i -e 'apache2'  # 忽略大小写且只显示存在的文件
locate /data/ | grep '/data/[^/]*\.log$' # 查找 /data 目录下一级子目录中的 log 文件
locate "$(pwd)/*.txt" #查找当前文件夹下所有txt文件
#locate的速度比find快，它并不是真的查找，而是查数据库，一般文件数据库在/var/lib/mlocate/mlocate.db中，所以locate的查找并不是实时的，而是以数据库的更新为准，一般是系统自己维护，也可以手工升级数据库 ，命令为：updatedb


#20 tar
-z       #表示打包的同时使用gzip的方式压缩
-j       #以 bzip2 方式压缩打包
-c       #表示创建一个压缩包文件
-v       #表示 显示操作过程
-f       #识别压缩路径信息
-t       #查看压缩包内文件     tf
-x       #解压               zxvf
-tf      #不解压的方式查看压缩的内容
-zxvf    #解压压缩包
-cvf     #打包
-rvf     #追加到已存在包
-xvf     #解压包
tar -zcvf name.tar.gz file1 ... filen #打包再压缩成gzip
tar -zxvf name.tar.gz                 #解压缩在取消打包
tar -jcvf name.tar.gz file1 ... filen #打包再压缩成bzip2
tar -jxvf name.tar.bz2 -C /path/      #解压到指定目录
#不可以用find 作批量压缩命令
#find 路径... -exec  tar {} \; ×
#会造成压缩数据信息的覆盖！
#压缩数据时,如果使用绝对路径压缩数据，要把"/"移除.如果有"/"只能压缩到根目录下,没有"/"可以将文件压缩到指定目录(不懂)

#21 zip
-r	     #递归地将一个目录及其所有子目录和文件压缩到ZIP文件中
-q	     #在压缩文件时启用静默模式，即不显示压缩过程的详细信息
-d	     #从现有的ZIP文件中删除指定的文件或目录
-u	     #用于更新现有的ZIP文件，将新的文件或修改后的文件添加到ZIP存档中
-f	     #用于刷新（更新）现有ZIP文件中的指定文件。
-m	     #用于移动（归档）文件到一个ZIP压缩文件中，并在移动后将源文件删除。
-e	     #用于对ZIP压缩文件进行加密。
-z	     #为压缩文件添加注释
zip -r 压缩包名.zip 文件1 文件2 文件n
zip -r test.zip /home/test -x "/home/test/test01/*" #排除test01目录 -x 指定排除目录，注意没有双引号将不起作用。
 zip -r test.zip test/ -z #添加注释信息。添加完成后输入回车后输入 . 之后再输入回车来结束

# gzip 和 bzip2
gunzip a.txt.gz
gzip -d a.txt.gz
bunzip2 a.bz2
bzip2 -d a.bz2

#ln
ln /etc/services /data/link_hard  #创建硬链接
ln -s /etc/services /data/link_soft  #创建软链接
```



## 用户及权限管理

### 用户介绍

用户信息: 可以作为系统数据或者程序进程操作管理者

用户组信息:可以将多个系统用户进行整合,方便统一对多个用户的权限进行管理

**用户**

| 字符 | 含义            |
| ---- | --------------- |
| u    | 所属主   uid    |
| g    | 所属组   gid    |
| o    | 其他人   others |
| a    | 所有人   all    |

**用户相关文件信息配置文件**：/etc/passwd

![image-20250719223400503](【Linux】总结/image-20250719223400503.png)

以：为分隔符 分为若干部分

```bash
用户名:密码占位符:用户ID(UID):组ID(GID):用户描述:家目录:登录Shell
```

- 用户名：字符串（如root），用于用户登录，长度限制为 32 字符。
- 密码占位符：通常为x，表示密码已加密存储在/etc/shadow中。若为空则表示无需密码登录（危险）。
- UID：整数，0 为 root 用户，1-999 为系统用户，1000 + 为普通用户。
- GID：对应/etc/group中的主组 ID。
- 用户描述：可选信息（如John Doe），通常用于注释。
- 家目录：用户登录后的默认目录（如/home/user），root 用户为/root。
- 登录 Shell：用户登录后使用的 Shell 程序（如/bin/bash），/sbin/nologin表示禁止登录。

**用户加密密码和密码策略**：/etc/shadow 

```bash
用户名:加密密码:最后修改日期:最小修改间隔:最大修改间隔:警告期:非活跃期:过期日期:保留字段
```

加密密码使用` $id$salt$hash` 格式存储（如 `$6$...` 表示 SHA-512），`!` 或 `*` 表示账户锁定。

**用户组信息:**/etc/group

### **权限介绍**

|  字符  | 权限                                 |
| :----: | ------------------------------------ |
| w---4  | 写权限                               |
| r----2 | 读权限                               |
| x----1 | 执行权限（脚本文件先赋权才能再执行） |

![image-20250719211822282](【Linux】总结/image-20250719211822282.png)

**r 读权限 4**

- 针对文件：利用此权限可以看到文件中的内容 cat
- 针对目录：可以看到目录下有什么数据 ls/目录

**w 写权限 2**

- 针对文件：利用此权限可以编辑文件中的内容 vim echo> >>
- 针对目录: 利用此权限可以在目录中创建 删除文件信息 修改文件名称信息

**x 执行权限 1**

- 针对文件:利用此权限 执行脚本信息
- 针对目录:利用此权限可以切换到目录中

另 X：针对目录加执行权限，文件不加执行权限（因文件具备执行权限有安全隐患）

**企业真实场景权限配置:**

默认配置:

文件权限: 644 属主拥有读和写写权限 属组和其他用户只有读权限

目录权限: 755 属主拥有查看编辑进入权限 属组和其他用户只有查看进入权限

严格权限:

文件权限: 600 只有属主有读和写权限

目录权限: 700 只有属主有读写和进入权限





### 特殊权限

Linux 中的文件权限除了常见的读（`r`）、写（`w`）、执行（`x`）权限外，还有三个**特殊权限**：`SetUID`（SUID）、`SetGID`（SGID）和`Sticky Bit`。它们用于解决一些特定的场景需求，通常设置于可执行文件或目录上，提供额外的权限控制功能。

------

####  **SetUID（SUID）**

- **符号表示：** `s`（出现在文件所有者的**执行权限**位置）
- **八进制表示：** `4`（如 `4755`）
- **作用：**
  - 当**可执行文件**设置了 SUID 权限时，**任何用户在执行该文件期间**，会临时获得该**文件所有者**的权限。
  - 核心目的：允许普通用户以文件所有者的身份执行特定任务（通常是需要特权才能完成的任务）。
- **经典例子：** `/usr/bin/passwd`
  - 普通用户（如 `user1`）需要修改自己的密码，密码最终存储在 `/etc/shadow`（该文件只有 `root` 可读写）。
  - `passwd` 命令被设置了 SUID 且所有者是 `root`（权限 `-rwsr-xr-x`）。
  - 当 `user1` 执行 `passwd` 时，进程临时获得 `root` 权限，从而能修改 `/etc/shadow`。
- **设置与查看：**
  - 设置：`chmod u+s 文件名` 或 `chmod 4xxx 文件名` (e.g., `chmod 4755 myprogram`)
  - 查看：如果所有者原本有 `x` 权限，`ls -l` 中所有者执行位显示为 `s`，如果所有者原本*没有* `x` 权限，则执行位显示为 `S`。
- **重要安全提示：** SUID 权限非常强大且**危险性很高**。不当设置（尤其是对脚本或不可信程序）会带来严重安全漏洞。应仅授予绝对必要且经过严格审查的可执行文件。

------

#### **SetGID（SGID）**

- **符号表示：** `s`（出现在所属组的**执行权限**位置）
- **八进制表示：** `2`（如 `2755`）
- **作用（取决于应用对象）：**
  - **应用于可执行文件：**
    - 与 SUID 类似，但作用于**组**。
    - 任何用户在执行设置了 SGID 的文件时，会临时获得该**文件所属组**的权限。
    - 目的：允许用户以文件所属组的身份执行任务（通常用于共享资源访问）。
  - **应用于目录：**
    - 这是 SGID **更常见且重要的用途**。
    - 在设置了 SGID 的目录中，**任何用户在此目录下创建的新文件或子目录**，其所属组**自动继承该目录的所属组**，而不是用户自己的默认主组。
    - 核心目的：**强制协作共享**。确保在共享目录中创建的所有文件都属于同一个特定组，方便组成员共同管理，无需手动修改组权限。
- **经典例子（目录）：** 项目共享目录 `/shared/projectX`
  - 设置所属组为 `projectx-team`：`chgrp projectx-team /shared/projectX`
  - 设置 SGID：`chmod g+s /shared/projectX` 或 `chmod 2775 /shared/projectX`
  - 现在，无论 `userA`（主组 `groupA`）还是 `userB`（主组 `groupB`）在 `/shared/projectX` 下创建文件 `report.txt`，该文件的所属组都会是 `projectx-team`（而不是 `groupA` 或 `groupB`）。
- **设置与查看：**
  - 设置：`chmod g+s 文件名/目录名` 或 `chmod 2xxx 文件名/目录名` (e.g., `chmod 2775 sharedir`)
  - 查看：如果组原本有 `x` 权限，`ls -l` 中组执行位显示为 `s`，如果组原本*没有* `x` 权限，则组执行位显示为`S`。
- **安全提示：** SGID 的风险通常低于 SUID，但仍需谨慎设置于可执行文件。在目录上的应用是安全且推荐的文件共享方式。

------

#### **Sticky Bit**

- **符号表示：** `t`（出现在其他用户的**执行权限**位置）
- **八进制表示：** `1`（如 `1777`）
- **作用：**
  - 仅对**目录**有意义。
  - 在设置了 Sticky Bit 的目录中，**用户只能删除或重命名自己拥有的文件或目录**，即使该目录的写权限 (`w`) 对其他用户开放（如 `rwxrwxrwt`）。
  - 核心目的：**保护用户文件不被他人误删**。在全局可写的目录中（如临时目录），防止用户随意删除他人的文件。
- **经典例子：** 系统临时目录 `/tmp`
  - 权限通常是 `drwxrwxrwt`。
  - 所有用户都有读、写、执行权限。
  - 末尾的 `t` 表示 Sticky Bit 已设置。
  - 用户 `user1` 可以在 `/tmp` 创建文件 `/tmp/user1file`。
  - 用户 `user2` 虽然对整个 `/tmp` 有写权限，但**不能删除或重命名** `/tmp/user1file`（除非他是 `root` 或文件所有者 `user1`）。`user2` 可以创建自己的 `/tmp/user2file`。
- **设置与查看：**
  - 设置：`chmod o+t 目录名` 或 `chmod 1xxx 目录名` (e.g., `chmod 1777 /public/tmp`)
  - 查看：如果其他用户原本有 `x` 权限，`ls -l` 中其他用户执行位显示为 `t`，如果其他用户原本*没有* `x` 权限，其他用户执行位显示为`T`。
- **应用场景：** 主要用于全局可写的共享临时目录（如 `/tmp`）。现代 Linux 中，对用户主目录 (`~`) 或普通共享目录（使用 SGID 管理组）通常不需要设置 Sticky Bit。

------

#### **特殊权限总结**

| 权限名称       | 符号              | 八进制值 | 主要作用对象   | 核心功能                           |
| -------------- | ----------------- | -------- | -------------- | ---------------------------------- |
| **SUID**       | `s` (所有者x位)   | `4`      | **可执行文件** | 执行时获得**文件所有者**权限       |
| **SGID**       | `s` (组x位)       | `2`      | **可执行文件** | 执行时获得**文件所属组**权限       |
|                |                   |          | **目录**       | 目录下**新建文件继承目录的组**     |
| **Sticky Bit** | `t` (其他用户x位) | `1`      | **目录**       | **仅文件所有者可删除**目录下的文件 |

------

**查看系统中的特殊权限实例**

- **SUID:** `ls -l /usr/bin/passwd` (应看到 `-rwsr-xr-x`)
- **SGID (目录):** `ls -ld /var/mail` (很多系统设置为 `drwxrwsr-x`)
- **Sticky Bit:** `ls -ld /tmp` (应看到 `drwxrwxrwt`)

理解并正确使用这三个特殊权限对于 Linux 系统管理、权限规划和系统安全至关重要。务必谨慎设置 SUID，善用 SGID 管理共享目录，并在需要全局可写临时目录时使用 Sticky Bit。

### sudoers权限分配

**`sudoers`文件编辑与定位**

执行`visudo`命令进入编辑界面后，可通过`100gg`快捷键快速定位至文件第 100 行附近（具体行数需根据系统版本及配置历史调整，通常用于找到预设的用户权限配置段），在此处可添加或修改用户的`sudo`权限规则。

**验证`sudoers`配置正确性**

配置完成后，需通过`visudo -c`命令验证`/etc/sudoers`文件的语法合法性，确保无格式错误：

```bash
[01:18:44 root@centon7 tmp]# visudo -c
/etc/sudoers：解析正确
```

若输出 “解析正确”，则说明配置文件语法无误，可正常生效。

**查看系统用户与权限配置**

在`/etc/sudoers`中，用户权限规则的典型配置格式为：

```bash
用户名  ALL=(ALL)  /sbin/useradd,/bin/cat
```

其中：

- `ALL=(ALL)`表示该用户可在所有主机上以所有用户身份执行命令；
- 末尾的`/sbin/useradd,/bin/cat`为允许执行的具体命令列表（多命令用逗号分隔）。

**查看用户`sudo`权限**

对于已配置`sudo`权限的用户，可通过`sudo -l`命令查看自身被授权的具体操作，便于验证权限分配是否符合预期：

```bash
sudo -l
```

该命令会列出当前用户可通过`sudo`执行的所有命令及相关限制。

### 用户及权限管理命令

```bash
#1 chmod
chmod XXX filename   #数字赋权
chmod +x filename    #添加执行权
chmod u+x,g+x,o+x  filename   #所有用户添加执行权==chmod +x filename==chmod a+x filename
chmod ug+w,o-w 1.txt 2.txt
chmod a=wx c.txt
chmod -R             # 命令表示将某个目录下面所有的内容都增加相应权限

#id
id user              #查看用户的 UID、GID 以及所属的用户组列表
id                   #查看自己的 UID、GID 以及所属的用户组列表
#whoami   可以查看当前系统操作者  即 登录的用户
#w        可以查看当前系统登录的用户信息   指的是 正在连接登录的用户信息

#useradd  --添加用户信息
-c   #设置用户备注信息
-u   #设置指定用户所属主   uid
-g   #设置用户所属组信息   gid
-G   #设置用户所属的附加组   
-M   #设置用户不创建家目录（创建虚拟用户）
-s   #设置用户是否能登录（创建虚拟用户）
useradd -g users -c "hr tom" tom

#su      切换用户：表示替换或转换用户身份 不完全切换
#su -    完全切换 用户相关环境变量信息会一并彻底切换
#sudo    提权，但需要先对特殊操作进行权限分配

#passwd  设置/更改密码
#面交互方式创建用户并设置密码（可利用脚本创建用户）
useradd xhy
echo 123456|passwd --stdin xhy

#userdel  
userdel  用户名     #保留用户家目录的数据
userdel -r  用户名  #彻底删除用户信息

#usermod 参数 匹配信息 对象
-c   #修改用户备注信息
-u   #修改指定用户所属主   uid
-g   #修改用户所属组信息   gid
-G   #修改用户所属的附加组   
-aG  #添加用户到多个附加组
-M   #修改用户不创建家目录（创建虚拟用户）
-s   #修改用户是否能登录（创建虚拟用户）
-l	 #指定新的用户名
-d	 #可选参数，同时修改用户的家目录路径
-m	 #与 -d 配合使用，将原家目录内容移动到新路径
usermod -l newuser -d /home/newuser -m olduser

#chown:修改文件属主和属组
chown root /var/log/httpd.log     # 更改文件所有者为root
chown :staff /home/user/file.txt  # 仅更改文件所属组为staff
chown user1:group1 /data/project  # 同时更改目录的所有者和组
chown  -R  主:组 文件               #递归更改目录及其所有子文件、子目录的所有权
-h                                #仅更改符号链接本身的所有权，而非其指向的目标文件。

#gpasswd
gpasswd -a 用户 组	#添加用户到组
gpasswd -d 用户 组	#从组中删除用户

#chattr
chattr -i          #重要文件上锁
chattr -i p        #解锁（可以将命令名称改名，这样黑客就不知道怎么解锁了）
```

## 磁盘管理

```bash
#1 du
du -sh filePath   #文件存储到磁盘所占的空间（block）
#查看文件大小
du -h
du -ah
#查看分区
df -h

#df [选项] [文件或设备]
-h    #以人类可读的格式显示磁盘空间大小
-T    #显示文件系统类型
-i    #显示 inode 信息
df    #显示磁盘空间大小

#mount 挂载硬盘
#umount 取消挂载
```

## vim使用

普通模式:

```bash
yy     #复制光标所在行
nyy    #数字yy 复制连续多行内容
p      #粘贴复制/剪切的内容
np     #粘贴n次复制/剪切的内容 
dd     #删除光标所在行
ndd    #删除n行
D	   #删除本行内容，但是保留空行
dG     #删除光标所在位置后的所有行内容
G      #光标跳转到最后一行
gg	   #光标跳转到第一行
nG     #光标跳转到第n行
$      #光标跳转当前行的末尾
0      #光标跳转到当前行的开头
Ctrl+u #undo
ctrl+r #redo
```

末行模式(命令模式)：

```bash
:/要检索的内容      #检索
: %s/root/ROOT/g #替换
:set nu          #显示行号 
:q               #不保存退出
:q!              #强制不保存退出
:wq              #保存退出
:wq!             #强制保存退出
:e!              #恢复到最初状态
:w a.txt         #另存为
:w >> a.txt      #内容追加到a.txt
```

每次进入vi就有行号编辑文件`.vimc`添加`set nu`

```bash
vi ~/.vimrc
set nu
```

